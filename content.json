{"pages":[{"title":"404","text":"","path":"404/index.html","date":"03-10","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"03-10","excerpt":""},{"title":"目录","text":"","path":"categories/index.html","date":"03-11","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"03-10","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"03-10","excerpt":""}],"posts":[{"title":"堆排序","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class HeapSort &#123; //因多个方法都会用到数据长度，故设置为成员变量 int len; /** * 进行排序 * @param args */ public void sort(int args[]) &#123; //判断数组是否有效或需要排序 if (args == null || args.length &lt; 1) return; BuildMinHeap(args); for (int i = args.length - 1; i &gt;= 0; i--) &#123; swap(args, 0, i); len--; heapifly(args, 0); &#125; &#125; /** * 以现有数组构建小頂堆 * @param args */ public void BuildMinHeap(int args[]) &#123; len = args.length; for (int i = len / 2; i &gt;= 0; i--) &#123; heapifly(args, i); &#125; &#125; /** * 从上往下堆化 * @param args * @param index */ public void heapifly(int args[], int index) &#123; while(true) &#123; int left = index * 2; int right = index * 2 + 1; int max = index; if (left &lt; len &amp;&amp; args[left] &gt; args[index]) &#123; max = left; &#125; if (right &lt; len &amp;&amp; args[right] &gt; args[max]) &#123; max = right; &#125; if (max == index) break; swap(args, max, index); index = max; &#125; &#125; /** * 交换数据 * @param args * @param i * @param j */ public void swap(int args[], int i, int j) &#123; int tmp = args[i]; args[i] = args[j]; args[j] = tmp; &#125;&#125; 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/13/heapSort/","date":"03-13","excerpt":"","tags":[]},{"title":"堆的代码实现","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100class Heap&#123; //数组总长度 int size; //数组元素个数 int count; //数组本身 int args[]; /** * 初始化堆 * @param len */ public Heap(int len) &#123; size = len; count = 0; args = new int[len + 1]; &#125; /** * 插入元素 * @param value */ public void insert(int value) &#123; if (count &gt;= size) return; args[++count] = value; heapify1(count); &#125; /** * 取出堆顶元素 * @return */ public int poll() &#123; if (count == 0) return -1; int res = args[1]; args[1] = args[count--]; heapify2(1); return res; &#125; /** * 从下往上堆化 * @param index */ public void heapify1(int index) &#123; while (index / 2 &gt; 0 &amp;&amp; args[index] &gt; args[index / 2]) &#123; swap(index, index / 2); index /= 2; &#125; &#125; /** * 从上往下堆化 * @param index */ public void heapify2(int index) &#123; int left = index * 2; int right = index * 2 + 1; int max = index; if (left &lt;= count &amp;&amp; args[left] &gt; args[index]) &#123; max = left; &#125; if (right &lt;= count &amp;&amp; args[right] &gt; args[max]) &#123; max = right; &#125; if (max != index) &#123; swap(index, max); heapify2(max); &#125; &#125; /** * 交换元素 * @param i * @param j */ public void swap(int i, int j) &#123; int tmp = args[i]; args[i] = args[j]; args[j] = tmp; &#125; /** * 打印堆 */ public void print() &#123; for (int i = 1; i &lt;= count; i *= 2) &#123; for (int j = i; j &lt; i*2; j++) &#123; if (j &lt;= count) System.out.print(args[j] + &quot; &quot;); &#125; System.out.println(); &#125; &#125;&#125; 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/13/heap/","date":"03-13","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/数据结构与算法/"}]},{"title":"堆和堆排序","text":"堆（Heap）什么是堆堆是一种特殊的树，它必须满足以下两点要求： 堆是一个完全二叉树。 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 每个节点的值都大于等于其子树中每个节点的值的数，叫左“大顶堆”。每个节点的值都小于等于其子树中每个节点的值的数，叫左“小顶堆”。 如何实现堆如何存储堆用数组储存完全二叉树是非常节省空间的。因为我们不需要存储左右子节点的指针，只要用数组下标，就可以找到一个节点的左右子节点和父节点。 堆支持哪些操作堆主要的操作有：插入元素和取出堆顶元素。 插入元素往堆中插入一个元素后，我们需要继续满足堆的特性。如果我们直接把新插入的元素放在堆尾，它就不符合堆的特性了。所以，我们要进行调整，重新满足堆的特性，这一过程叫左“堆化”。 而堆化非常简单，就是顺着节点所在路径往上或往下进行对比和交换。堆化有两种方式，一是“从上往下堆化”，二是“从下往上堆化”。 “从下往上堆化”以小顶堆为例，我们让新插入的节点与其父节点进行对比，如果不满足子节点都小于等于父节点的关系，就把它们两个互换。一直重复这个过程，直到父子节点之间满足关系。 “从上往下堆化”同样以小顶堆为例，“从上往下堆化”通常发生在取出栈顶元素之后，我们拿出堆顶元素后，将最后一个元素放到堆顶，然后让该元素与其左右子节点进行对比，如果不满足子节点都小于等于父节点的关系，就把它与不符合要求的子节点交换。一直重复这个过程，直到父子节点之间满足关系。 由于每次我们都是对数组的最后一个元素进行操作，而且堆化进行的都是交换操作，所以不会出现数组”空洞”。 关于堆的代码实现，详细请看：https://loliwithpick.github.io/deny.github.io/2019/03/13/heap/ 堆排序（HeapSort）堆排序是基于堆实现的排序算法，它是一种原地排序算法，时间复杂度为 O(nlogn)，由于涉及到数据交换，所以它是不稳定的。 如何实现堆排序堆排序主要有两个操作：建堆和排序。 建堆建堆有两种方法： 借助在堆中插入一个元素的思想。假设数组中的数据存放在下标从 1 到 n 内，堆中只包含一个数据（下标为 1 的数据）。然后调用堆的插入方法，依次把剩下的数据插入到堆中。该方法是从下往上堆化的。 我们直接对数组进行堆化，而这种操作是从上往下堆化的。我们首先从最后一个非叶子节点开始，分别跟其左右子节点比较和堆化，依次往前。这么说法会很难理解，我们直接从代码方面下手。 123456789101112131415161718192021222324252627282930313233343536/** * 以现有数组构建小頂堆 * @param args */public void BuildMinHeap(int args[]) &#123; len = args.length; for (int i = len / 2; i &gt;= 0; i--) &#123; heapifly(args, i); &#125;&#125;/** * 从上往下堆化 * @param args * @param index */public void heapifly(int args[], int index) &#123; while(true) &#123; int left = index * 2; int right = index * 2 + 1; int max = index; if (left &lt; len &amp;&amp; args[left] &gt; args[index]) &#123; max = left; &#125; if (right &lt; len &amp;&amp; args[right] &gt; args[max]) &#123; max = right; &#125; if (max == index) break; swap(args, max, index); index = max; &#125;&#125; 在完全二叉树中，下标为 n/2 + 1 到 n 的节点是叶子节点。所以我们从下标为 n/2 开始，依次往前进行堆化的。所以我们只需从下标为 n/2 开始，依次往前进行堆化。 排序假设我们建的是大顶堆，那么建堆后，数组中的数据是按照大顶堆特性进行的。堆顶元素是最大的元素，我们将它与最后一个元素进行交换，那么最大的元素就放在下标为 n 的位置，然后我们将堆长度减一，重复进行前面的操作，最终就得到一个升序排序的数组。 123456789101112131415/** * 进行排序 * @param args */public void sort(int args[]) &#123; //判断数组是否有效或需要排序 if (args == null || args.length &lt; 1) return; BuildMinHeap(args); for (int i = args.length - 1; i &gt;= 0; i--) &#123; swap(args, 0, i); len--; heapifly(args, 0); &#125;&#125; 关于堆排序的代码实现，请观看：https://loliwithpick.github.io/deny.github.io/2019/03/13/heapSort/ 以上均为个人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/13/heapTheory/","date":"03-13","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/数据结构与算法/"}]},{"title":"解决SSM框架\"Could not get JDBC Connection\"问题","text":"Could not get JDBC Connection; nested exception is org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (Could not create connection to database server.) 这个问题主要在于 jdbc。上网搜了下，因为百度限制字数的问题，迟迟找不到。然后到处找找，排除了下，终于解决了问题。 下面，我列出觉得会引起该问题的一些情况给大家看看。 jdbc.properties 文件内容的规范1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/XXX（你的数据库名）jdbc.username=adminjdbc.password=123456 该文件一定要符合标准规范，有时候会因为 driver 变量没有 jdbc 的前缀而导致出错。 spring-mybatis.xml 文件内容的规范1234567891011121314151617&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;initialSize&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;maxActive&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;maxIdle&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;minIdle&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;maxWait&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; property 的 value 属性内容一定要跟 jdbc.properties 文件的变量名一致。 注意引用的 jdbc 版本是否与数据库版本相符 我的问题就出现在这，因为我使用的是 mysql 8，而我 pom.xml 文件引用的 jdbc 版本是 5.1.30，导致 jdbc 版本与数据库版本不符。 所以，如果 1、2 点无法解决你的问题，请留意下第三点。 以上皆为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/12/jdbcError/","date":"03-12","excerpt":"","tags":[{"name":"编程错误","slug":"编程错误","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/编程错误/"}]},{"title":"插入排序","text":"插入排序（Insertion Sort）的原理很简单和直观。它通过构建有序序列，对未排序数据，在已排序序列中从后往前扫描，找到相应位置并插入。从第一个元素开始，一般认为头元素是已经被排序的。 12345678910111213141516171819202122/** * 插入排序 * @param args * @return int[] */public int[] insertionSort(int[] args) &#123; //判断数组是否合法或需要排序 if (args == null || args.length &lt; 2) &#123; return args; &#125; for (int i = 1; i &lt; args.length; i++) &#123; int index = i, tmp = args[i]; while (index &gt; 0 &amp;&amp; args[index - 1] &gt; tmp) &#123; args[index] = args[index - 1]; index--; &#125; args[index] = tmp; &#125; return args;&#125; 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/11/insertionSort/","date":"03-11","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/数据结构与算法/"}]},{"title":"快速排序","text":"快速排序（Quick Sort）是一种常见的时间复杂度为 O(nlogn) 的排序算法（有些人会把空间复杂度写为 O(logn）)。 它通过一趟排序将数据分成两个独立的部分，其中，一部分的数据均比另一部分的数据要小，然后分别对这两部分数据继续进行排序，重复多次，以达到整个序列有序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 快速排序 * @param args * @param left * @param right * return int[] */public int[] quickSort(int[] args, int left, int right) &#123; if (left &lt; right) &#123; int pivot = partition(args, left, right); quickSort(args, left, pivot - 1); quickSort(args, pivot + 1, right); &#125; return args;&#125;/** * * @param args * @param left * @param right * @return int */private int partition(int[] args, int left, int right) &#123; int pivot = right, index = left; for (int i = left; i &lt; right; i++) &#123; if (args[i] &lt; args[pivot]) &#123; swap(args, i, index); index++; &#125; &#125; swap(args, index, pivot); return index;&#125;/** * 交换数据 * @param args * @param i * @param j */private void swap(int[] args, int i, int j) &#123; int tmp = args[i]; args[i] = args[j]; args[j] = tmp;&#125; 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/11/quickSort/","date":"03-11","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/数据结构与算法/"}]},{"title":"冒泡排序","text":"冒泡排序（Bubble Sort）每次比较两个元素，如果他们的顺序相反了，就把它们交换。在最极端的情况下，元素顺序刚好是倒序，冒泡排序需要比较 n 次（n 为元素个数），才能完成排序。 12345678910111213141516171819202122/** * 冒泡排序 * @param args * @return int[] */public int[] bubbleSort(int[] args) &#123; //判断数组是否合法或需要排序 if (args == null || args.length &lt; 2) return args; for (int i = 0; i &lt; args.length; i++) &#123; for (int j = 1; j &lt; args.length; j++) &#123; if (args[j] &gt; args[j - 1]) &#123; int tmp = args[j]; args[j] = args[j - 1]; args[j - 1] = tmp; &#125; &#125; &#125; return args;&#125; 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/11/bubbleSort/","date":"03-11","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/数据结构与算法/"}]},{"title":"人们对萝莉的偏见","text":"起因，这一两天在弄个人博客，就想要自己喜欢的主题类型，然后就找了个动漫萝莉风的主题，这主题，我是越看越喜欢。可就有些同学一看到就嗤之以鼻，就说“你这人，总喜欢这些，真是一个变态”。听得我就纳闷了，你们是不是对“萝莉”有什么偏见，“萝莉”可是这世界上最令人向往的存在。我来给你们分析下，为什么这么说。 首先，举个例子： 我喜欢萝莉 ∵ 萝莉 = 可爱的富婆 ∴ 我喜欢可爱的富婆 又∵ 富婆 = 有很多很多钱，钱 = 毛爷爷 ∴ 我喜欢可爱的毛爷爷 那么问题来了，谁不喜欢毛爷爷？ 所以，请你们不要误会那些喜欢萝莉的人了，他们基本上跟你们没有区别，只是比你们更喜欢毛爷爷而已。","path":"2019/03/11/人们对萝莉的偏见/","date":"03-11","excerpt":"","tags":[{"name":"日常吐槽","slug":"日常吐槽","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/日常吐槽/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/03/11/hello-world/","date":"03-11","excerpt":"","tags":[]},{"title":"Java基础：对Java的理解","text":"在了解 Java 之前，我们得知道面向对象和面向过程的优劣。 面向过程优势：类不需要实例化，所以性能要比面向对象高。对性能要求比较高的开发一般都采用面向过程语言，比如单片机、嵌入式开发、Linux/Unix 等。 劣势：没有面向对象易复用、易扩展、易维护。 面向对象优势：面向对象具有封装、继承和多态的特性。与面向过程相比，更容易复用、扩展和维护。不仅如此，还能设计出低耦合的系统，使系统更加灵活，更容易维护。 劣势：由于类的实例化开销较大，所以，性能比面向过程低。 关于封装、继承和多态封装封装是把一个对象的属性私有化，然后为每个属性创建 getter、setter 方法供外界访问。 继承继承是父子关系，以一个类作为父亲创建新类，新类又叫子类，子类拥有父类中非 private 的属性和方法，也可以拥有自己的属性和方法。通过继承，我们可以非常方便的复用代码。 多态多态是指在编程时，程序不知道引用变量会指向哪个类的实例对象，更不知道该变量的方法调用是哪个类实现的方法，只有在程序运行时才能确定。 Java 两大特性Java 本身是面向对象语言，具有面向对象的三大特点（封装、继承、多态），最显著的特性有两个方面，分别是“一次书写，到处运行。”和“垃圾收集“。 “一次书写，到处运行。”（Write once，run anywhere）Java 通过字节码和 JVM 跨平台的抽象屏蔽了系统和硬件的细节。 JVM 可理解的代码叫字节码（即后缀为 .class 的文件）。字节码不面向任何特定的处理器，只面向 JVM。而 JVM 针对不同系统有特定实现，目的是为了使用相同的字节码，在不同系统运行都会给出相同的结果。 JAVA 通过字节码的方式，在一定程度上解决了传统解释型语言执行效率的问题，同时也保留了解释型代码可移植的特点。因此，Java 具有“一次书写，到处运行”的特点。 “垃圾收集”（Garbage Collection）很多人都会拿 C++ 与 Java 相比，在 C++ 中，最令人头疼的就是内存管理问题，而 Java 的显著特点之一就是引入了垃圾回收机制，它会自动回收分配内存，使得 Java 程序员在大部分情况下都不需要操心内存的分配和回收。 Java 运行环境除了要知道 Java 的特性之外，我们还得知道 Java 的运行环境，JDK 和 JRE。 JRE（Java Runtime Environment）JRE 是 Java 的运行环境，包含了 JVM 和 Java 类库（核心类库、安全类库、第三方类库等），Java 命令和其他一些基础构建。但它不能用于创建新程序。 JDK（Java Development Kit）JDK 可看作是 JRE 的一个超集，包含 JRE 的一切，还提供了更多的工具（辅助工具：jlink、jar、jdeps 等，编译器：javac、sjavac 等，诊断工具：jmap、jstack、jconsole等）。能够创建和编译程序。 Java 是编译与解释并存的语言虽然 Java 是解释机制，但它是编译与解释并存的语言。 Java 代码从编译到运行的机制是：Java 代码经过 Javac 编译成 .class 文件，然后 JVM 类加载器加载 .class 文件，最后通过解释器逐行解释运行。照这么说法，Java 应该是解释执行才对，何来的编译呢？其实，这种方法的执行速度相对较慢，并且有些代码块经常被调用，在时间消耗上占了很大一部分。所以，存在 JIT（Just-In-Time）编译器，把经常运行的代码作为“热点代码”编译成本地平台相关的机器码，并进行各种层次的优化。所以，Java 是编译与解释并存的语言。 JDK 9 引入了新的编译模式 AOT，它预先把字节码编译成机器码。 如果需要了解 JIT 和 AOT，详细请观看 JIT（动态编译）和AOT（静态编译）编译技术比较 Java 与 C++ 的区别据闻，很多时候都会拿 Java 和 C++ 作比较，本人看来，每个语言都有它的特点，得看情况使用。 它们都是面向对象语言，都支持封装、继承和多态。 Java 没有指针，程序内存更安全。 C++ 支持多重继承，而 Java 只支持单继承，但可以有多个接口。 Java 能自动回收和分配内存，一般情况下，不需要手动释放内存。 C++ 支持本地的无符号数学运算，而 Java 不支持。 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/10/对Java的理解/","date":"03-10","excerpt":"","tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/编程语言/"}],"preview":"/deny.github.io/imgs/preview/preview5.jpg"}]}