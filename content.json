{"pages":[{"title":"404","text":"","path":"404/index.html","date":"03-10","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"03-10","excerpt":""},{"title":"目录","text":"","path":"categories/index.html","date":"03-11","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"03-10","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"03-10","excerpt":""}],"posts":[{"title":"插入排序","text":"插入排序（Insertion Sort）的原理很简单和直观。它通过构建有序序列，对未排序数据，在已排序序列中从后往前扫描，找到相应位置并插入。从第一个元素开始，一般认为头元素是已经被排序的。 12345678910111213141516171819202122/** * 插入排序 * @param args * @return int[] */public int[] insertionSort(int[] args) &#123; //判断数组是否合法或需要排序 if (args == null || args.length &lt; 2) &#123; return args; &#125; for (int i = 1; i &lt; args.length; i++) &#123; int index = i, tmp = args[i]; while (index &gt; 0 &amp;&amp; args[index - 1] &gt; tmp) &#123; args[index] = args[index - 1]; index--; &#125; args[index] = tmp; &#125; return args;&#125; 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/11/insertionSort/","date":"03-11","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/数据结构与算法/"}]},{"title":"快速排序","text":"快速排序（Quick Sort）是一种常见的时间复杂度为 O(nlogn) 的排序算法（有些人会把空间复杂度写为 O(logn）)。 它通过一趟排序将数据分成两个独立的部分，其中，一部分的数据均比另一部分的数据要小，然后分别对这两部分数据继续进行排序，重复多次，以达到整个序列有序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 快速排序 * @param args * @param left * @param right * return int[] */public int[] quickSort(int[] args, int left, int right) &#123; if (left &lt; right) &#123; int pivot = partition(args, left, right); quickSort(args, left, pivot - 1); quickSort(args, pivot + 1, right); &#125; return args;&#125;/** * * @param args * @param left * @param right * @return int */private int partition(int[] args, int left, int right) &#123; int pivot = right, index = left; for (int i = left; i &lt; right; i++) &#123; if (args[i] &lt; args[pivot]) &#123; swap(args, i, index); index++; &#125; &#125; swap(args, index, pivot); return index;&#125;/** * 交换数据 * @param args * @param i * @param j */private void swap(int[] args, int i, int j) &#123; int tmp = args[i]; args[i] = args[j]; args[j] = tmp;&#125; 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/11/quickSort/","date":"03-11","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/数据结构与算法/"}]},{"title":"冒泡排序","text":"冒泡排序（Bubble Sort）每次比较两个元素，如果他们的顺序相反了，就把它们交换。在最极端的情况下，元素顺序刚好是倒序，冒泡排序需要比较 n 次（n 为元素个数），才能完成排序。 12345678910111213141516171819202122/** * 冒泡排序 * @param args * @return int[] */public int[] bubbleSort(int[] args) &#123; //判断数组是否合法或需要排序 if (args == null || args.length &lt; 2) return args; for (int i = 0; i &lt; args.length; i++) &#123; for (int j = 1; j &lt; args.length; j++) &#123; if (args[j] &gt; args[j - 1]) &#123; int tmp = args[j]; args[j] = args[j - 1]; args[j - 1] = tmp; &#125; &#125; &#125; return args;&#125; 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/11/bubbleSort/","date":"03-11","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/数据结构与算法/"}]},{"title":"人们对萝莉的偏见","text":"起因，这一两天在弄个人博客，就想要自己喜欢的主题类型，然后就找了个动漫萝莉风的主题，这主题，我是越看越喜欢。可就有些同学一看到就嗤之以鼻，就说“你这人，总喜欢这些，真是一个变态”。听得我就纳闷了，你们是不是对“萝莉”有什么偏见，“萝莉”可是这世界上最令人向往的存在。我来给你们分析下，为什么这么说。 首先，举个例子： 我喜欢萝莉 ∵ 萝莉 = 可爱的富婆 ∴ 我喜欢可爱的富婆 又∵ 富婆 = 有很多很多钱，钱 = 毛爷爷 ∴ 我喜欢可爱的毛爷爷 那么问题来了，谁不喜欢毛爷爷？ 所以，请你们不要误会那些喜欢萝莉的人了，他们基本上跟你们没有区别，只是比你们更喜欢毛爷爷而已。","path":"2019/03/11/人们对萝莉的偏见/","date":"03-11","excerpt":"","tags":[{"name":"日常吐槽","slug":"日常吐槽","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/日常吐槽/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/03/11/hello-world/","date":"03-11","excerpt":"","tags":[]},{"title":"Java基础：对Java的理解","text":"在了解 Java 之前，我们得知道面向对象和面向过程的优劣。 面向过程优势：类不需要实例化，所以性能要比面向对象高。对性能要求比较高的开发一般都采用面向过程语言，比如单片机、嵌入式开发、Linux/Unix 等。 劣势：没有面向对象易复用、易扩展、易维护。 面向对象优势：面向对象具有封装、继承和多态的特性。与面向过程相比，更容易复用、扩展和维护。不仅如此，还能设计出低耦合的系统，使系统更加灵活，更容易维护。 劣势：由于类的实例化开销较大，所以，性能比面向过程低。 关于封装、继承和多态封装封装是把一个对象的属性私有化，然后为每个属性创建 getter、setter 方法供外界访问。 继承继承是父子关系，以一个类作为父亲创建新类，新类又叫子类，子类拥有父类中非 private 的属性和方法，也可以拥有自己的属性和方法。通过继承，我们可以非常方便的复用代码。 多态多态是指在编程时，程序不知道引用变量会指向哪个类的实例对象，更不知道该变量的方法调用是哪个类实现的方法，只有在程序运行时才能确定。 Java 两大特性Java 本身是面向对象语言，具有面向对象的三大特点（封装、继承、多态），最显著的特性有两个方面，分别是“一次书写，到处运行。”和“垃圾收集“。 “一次书写，到处运行。”（Write once，run anywhere）Java 通过字节码和 JVM 跨平台的抽象屏蔽了系统和硬件的细节。 JVM 可理解的代码叫字节码（即后缀为 .class 的文件）。字节码不面向任何特定的处理器，只面向 JVM。而 JVM 针对不同系统有特定实现，目的是为了使用相同的字节码，在不同系统运行都会给出相同的结果。 JAVA 通过字节码的方式，在一定程度上解决了传统解释型语言执行效率的问题，同时也保留了解释型代码可移植的特点。因此，Java 具有“一次书写，到处运行”的特点。 “垃圾收集”（Garbage Collection）很多人都会拿 C++ 与 Java 相比，在 C++ 中，最令人头疼的就是内存管理问题，而 Java 的显著特点之一就是引入了垃圾回收机制，它会自动回收分配内存，使得 Java 程序员在大部分情况下都不需要操心内存的分配和回收。 Java 运行环境除了要知道 Java 的特性之外，我们还得知道 Java 的运行环境，JDK 和 JRE。 JRE（Java Runtime Environment）JRE 是 Java 的运行环境，包含了 JVM 和 Java 类库（核心类库、安全类库、第三方类库等），Java 命令和其他一些基础构建。但它不能用于创建新程序。 JDK（Java Development Kit）JDK 可看作是 JRE 的一个超集，包含 JRE 的一切，还提供了更多的工具（辅助工具：jlink、jar、jdeps 等，编译器：javac、sjavac 等，诊断工具：jmap、jstack、jconsole等）。能够创建和编译程序。 Java 是编译与解释并存的语言虽然 Java 是解释机制，但它是编译与解释并存的语言。 Java 代码从编译到运行的机制是：Java 代码经过 Javac 编译成 .class 文件，然后 JVM 类加载器加载 .class 文件，最后通过解释器逐行解释运行。照这么说法，Java 应该是解释执行才对，何来的编译呢？其实，这种方法的执行速度相对较慢，并且有些代码块经常被调用，在时间消耗上占了很大一部分。所以，存在 JIT（Just-In-Time）编译器，把经常运行的代码作为“热点代码”编译成本地平台相关的机器码，并进行各种层次的优化。所以，Java 是编译与解释并存的语言。 JDK 9 引入了新的编译模式 AOT，它预先把字节码编译成机器码。 如果需要了解 JIT 和 AOT，详细请观看 JIT（动态编译）和AOT（静态编译）编译技术比较 Java 与 C++ 的区别据闻，很多时候都会拿 Java 和 C++ 作比较，本人看来，每个语言都有它的特点，得看情况使用。 它们都是面向对象语言，都支持封装、继承和多态。 Java 没有指针，程序内存更安全。 C++ 支持多重继承，而 Java 只支持单继承，但可以有多个接口。 Java 能自动回收和分配内存，一般情况下，不需要手动释放内存。 C++ 支持本地的无符号数学运算，而 Java 不支持。 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/10/对Java的理解/","date":"03-10","excerpt":"","tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/编程语言/"}],"preview":"/deny.github.io/imgs/preview/preview5.jpg"}]}