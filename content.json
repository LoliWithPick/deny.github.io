{"pages":[{"title":"404","text":"","path":"404/index.html","date":"03-10","excerpt":""},{"title":"目录","text":"","path":"categories/index.html","date":"03-11","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"03-10","excerpt":""},{"title":"关于我","text":"我只是一个普普通通的萌新程序员，希望能提高自己的水平，也希望能接触更多的领域，做一个全能人。 目前，我主要学习 Java 和 数据结构与算法，目的是为了更好的工作和更高的薪资。","path":"about/index.html","date":"03-10","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"03-10","excerpt":""}],"posts":[{"title":"Java异常处理","text":"Java 的所有异常继承于 java.lang.Throwable 类，而该类有两个重要的子类，分别是 Exception 类和 Error 类。它们是异常处理机制的重要组成部分。异常的划分体现了设计者对不同异常的分类。 ExceptionException 是程序正常运行时，可能并且应捕获进行相应处理的。一般情况下分为两种，分别是检查性异常和运行时异常。 检查性异常（Checked Exception）检查性异常（Checked Exception）一般是由程序员或问题引起的，它必须在代码中显式地捕获并进行相应处理。比如，要打开一个不存在的文件会在编译期产生异常。 检查性异常的种类 名称 简介 ClassNotFoundException 类未找到异常 CloneNotSupportedException 克隆不支持异常 运行时异常（Runtime Exception）运行时异常（Runtime Exception）是程序运行时由解释器产生的异常，由于运行时异常在随处都可出现，并且出现频率高，所以编译器不会对它进行检查。在代码中不必显式地补货，而是根据需要去捕获它。比如，数组下标访问越界。 运行时异常的种类图 ErrorError 是程序无法处理的错误，是不可查的，一般发生于 JVM 本身或 JVM 运行程序时。因为错误是超出程序控制和处理能力之外的，所以，一个合理的程序，即便发生了错误，我们也不应该尝试去处理错误（注解：这里可能会有误解，这里说的处理不是说我们不解决错误，而是不要捕获和处理错误。）。比如，JVM 运行出错。 错误的种类图 异常处理异常处理原则 捕获特定异常，而不是通用异常 在捕获异常时，我们要保证我们的目的不被隐藏，并且保证程序不会捕获到我们不希望被捕获的异常。更不要尝试捕获 Throwable 和 Error，除非你真的需要，否则难以保证程序能正常处理 OutOfMemoryError。 不要生吞异常 生吞异常的意思是假设代码不会发生异常。由于种种原因，对于某些代码，我们不能完全保证其不会报错，所以，我们不能假设代码不会发生异常，否则的话，一旦发生错误，我们无从得知原因。 不使用 printStackTrace() 输出错误信息 printStackTrace() 方法会把出错信息输出到标准出错（STERR）。而标准出错不是合适的输出项，在生产环境中，极有可能无法收集错误信息。 异常处理方法我们可以使用 try-catch-finally 或者 throw、throws 来进行捕获处理异常。而其中 try-catch-finally 有着以下几点注意事项： try 块负责抛出异常，后面可以接 0 个或者多个 catch 块。如果没有 catch 块，那么必须要有 finally 块。 catch 块负责捕获与它关联的 try 块抛出的异常。 finally 块保证在方法返回前，执行块内的代码，无论是否抛出或捕获异常。比如，关闭 jdbc 连接，关闭输入输出流等。 出现下面 4 种情况时，finally 块不会执行。 finally 块发生异常。 在 finally 块之前通过 System.exit() 退出。 finally 块所在的线程被关闭。 cpu 关闭。 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/22/exception/","date":"03-22","excerpt":"","tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/编程语言/"}],"preview":"preview5"},{"title":"链表的各种基本操作","text":"链表的基本实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100class LinkList&#123; //存放头结点 Node head; //记录数据长度 int size; LinkList()&#123; head = new Node(); size = 0; &#125; class Node&#123; public int value = -1; public Node next = null; Node(int value) &#123; this.value = value; &#125; public Node()&#123;&#125; &#125; /** * 在链表头添加节点 * @param value */ public void addFirst(int value) &#123; final Node node = new Node(value); final Node nextN = head.next; node.next = nextN; head.next = node; size++; &#125; /** * 在链尾添加节点 * @param value */ public void addLast(int value) &#123; final Node node = new Node(value); Node cur = head; while (cur.next != null) cur = cur.next; cur.next = node; size++; &#125; /** * 指定位置添加节点 * @param value * @param index */ public void add(int value, int index) &#123; if (index &gt; size) return; Node pre = null, cur = head; final Node node = new Node(value); for (int i = 0; i &lt; index; i++) &#123; pre = cur; cur = cur.next; &#125; pre.next = node; node.next = cur; &#125; public int getSize() &#123; return size; &#125; /** * 删除链头节点并返回节点值 * @return */ public int removeFirst() &#123; if (size == 0) return -1; final Node node = head.next; final Node nextN = node.next; head.next = nextN; size--; return node.value; &#125; /** * 删除链尾节点并返回节点值 * @return */ public int removeLast()&#123; if (size == 0) return -1; Node cur = head; while (cur.next != null &amp;&amp; cur.next.next != null) &#123; cur = cur.next; &#125; final Node node = cur.next; cur.next = null; size--; return node.value; &#125; 反转链表12345678910111213141516/** * 反转链表 */public void reverse()&#123; if (size == 0) return; Node pre = null, cur = head.next; while (cur != null) &#123; Node tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; &#125; head.next = pre;&#125; 判断链表是否存在循环12345678910111213141516/** * 判断是否存在循环 */public boolean loopCheck()&#123; if (size == 0) return false; Node first = head.next; Node second = first.next; while (second != null &amp;&amp; second.next != null)&#123; if (first == second) return true; first = first.next; second = second.next.next; &#125; return false;&#125; 删除倒数第 k 个元素的两种方法123456789101112131415161718192021222324252627282930313233343536373839/** * 删除倒数第 k 个数（方法一） * @param k * @return */public int deleteDESC(int k) &#123; if (size == 0 || k &gt; size) return -1; Node cur = head; for (int i = 0; i &lt; (size - k); i++) &#123; cur = cur.next; &#125; final Node tmp = cur.next; cur.next = tmp.next; return tmp.value;&#125;/** * 删除倒数第 k 个数（方法二） * @param k * @return */public int deleteLastKth(int k) &#123; if (size == 0 || k &gt; size) return -1; Node first = head.next; while (k &gt; 1) &#123; first = first.next; k--; &#125; Node second = head.next, pre = head; while (first.next != null) &#123; first = first.next; pre = second; second = second.next; &#125; pre.next = second.next; return second.value;&#125; 回文链表的判断12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 /** * 判断是否回文链表 * @return */ public boolean palindrome()&#123; if (size &lt;= 1) return false; Node first = head.next, second = head.next.next, left, right; while (second.next != null &amp;&amp; second.next.next != null) &#123; first = first.next; second = second.next.next; &#125; if (second.next != null) &#123; right = first.next.next; left = reverse(first); &#125; else &#123; right = first.next; left = reverse(first); &#125; return ToF(left, right); &#125; /** * 反转以参数节点为尾的链表 * @param node * @return */ public Node reverse(Node node) &#123; Node pre = null, cur = head.next; while (cur != node) &#123; Node tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; &#125; cur.next = pre; return cur; &#125; /** * 判断两个链表所有的节点值是否相等 * @param left * @param right * @return */ public boolean ToF(Node left, Node right) &#123; while (left != null &amp;&amp; right != null &amp;&amp; left.value == right.value) &#123; left = left.next; right = right.next; &#125; if (left == null &amp;&amp; right == null) return true; else return false; &#125; /** * 输出所有节点值 */ public void print() &#123; Node cur = head.next; while (cur != null) &#123; System.out.print(cur.value+&quot; &quot;); cur = cur.next; &#125; &#125;&#125; 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/15/linkedList/","date":"03-15","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/数据结构与算法/"}]},{"title":"堆排序","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class HeapSort &#123; //因多个方法都会用到数据长度，故设置为成员变量 int len; /** * 进行排序 * @param args */ public void sort(int args[]) &#123; //判断数组是否有效或需要排序 if (args == null || args.length &lt; 1) return; BuildMinHeap(args); for (int i = args.length - 1; i &gt;= 0; i--) &#123; swap(args, 0, i); len--; heapifly(args, 0); &#125; &#125; /** * 以现有数组构建小頂堆 * @param args */ public void BuildMinHeap(int args[]) &#123; len = args.length; for (int i = len / 2; i &gt;= 0; i--) &#123; heapifly(args, i); &#125; &#125; /** * 从上往下堆化 * @param args * @param index */ public void heapifly(int args[], int index) &#123; while(true) &#123; int left = index * 2; int right = index * 2 + 1; int max = index; if (left &lt; len &amp;&amp; args[left] &gt; args[index]) &#123; max = left; &#125; if (right &lt; len &amp;&amp; args[right] &gt; args[max]) &#123; max = right; &#125; if (max == index) break; swap(args, max, index); index = max; &#125; &#125; /** * 交换数据 * @param args * @param i * @param j */ public void swap(int args[], int i, int j) &#123; int tmp = args[i]; args[i] = args[j]; args[j] = tmp; &#125;&#125; 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/13/heapSort/","date":"03-13","excerpt":"","tags":[]},{"title":"堆的代码实现","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100class Heap&#123; //数组总长度 int size; //数组元素个数 int count; //数组本身 int args[]; /** * 初始化堆 * @param len */ public Heap(int len) &#123; size = len; count = 0; args = new int[len + 1]; &#125; /** * 插入元素 * @param value */ public void insert(int value) &#123; if (count &gt;= size) return; args[++count] = value; heapify1(count); &#125; /** * 取出堆顶元素 * @return */ public int poll() &#123; if (count == 0) return -1; int res = args[1]; args[1] = args[count--]; heapify2(1); return res; &#125; /** * 从下往上堆化 * @param index */ public void heapify1(int index) &#123; while (index / 2 &gt; 0 &amp;&amp; args[index] &gt; args[index / 2]) &#123; swap(index, index / 2); index /= 2; &#125; &#125; /** * 从上往下堆化 * @param index */ public void heapify2(int index) &#123; int left = index * 2; int right = index * 2 + 1; int max = index; if (left &lt;= count &amp;&amp; args[left] &gt; args[index]) &#123; max = left; &#125; if (right &lt;= count &amp;&amp; args[right] &gt; args[max]) &#123; max = right; &#125; if (max != index) &#123; swap(index, max); heapify2(max); &#125; &#125; /** * 交换元素 * @param i * @param j */ public void swap(int i, int j) &#123; int tmp = args[i]; args[i] = args[j]; args[j] = tmp; &#125; /** * 打印堆 */ public void print() &#123; for (int i = 1; i &lt;= count; i *= 2) &#123; for (int j = i; j &lt; i*2; j++) &#123; if (j &lt;= count) System.out.print(args[j] + &quot; &quot;); &#125; System.out.println(); &#125; &#125;&#125; 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/13/heap/","date":"03-13","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/数据结构与算法/"}]},{"title":"堆和堆排序","text":"堆（Heap）什么是堆堆是一种特殊的树，它必须满足以下两点要求： 堆是一个完全二叉树。 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 每个节点的值都大于等于其子树中每个节点的值的数，叫左“大顶堆”。每个节点的值都小于等于其子树中每个节点的值的数，叫左“小顶堆”。 如何实现堆如何存储堆用数组储存完全二叉树是非常节省空间的。因为我们不需要存储左右子节点的指针，只要用数组下标，就可以找到一个节点的左右子节点和父节点。 堆支持哪些操作堆主要的操作有：插入元素和取出堆顶元素。 插入元素往堆中插入一个元素后，我们需要继续满足堆的特性。如果我们直接把新插入的元素放在堆尾，它就不符合堆的特性了。所以，我们要进行调整，重新满足堆的特性，这一过程叫左“堆化”。 而堆化非常简单，就是顺着节点所在路径往上或往下进行对比和交换。堆化有两种方式，一是“从上往下堆化”，二是“从下往上堆化”。 “从下往上堆化”以小顶堆为例，我们让新插入的节点与其父节点进行对比，如果不满足子节点都小于等于父节点的关系，就把它们两个互换。一直重复这个过程，直到父子节点之间满足关系。 “从上往下堆化”同样以小顶堆为例，“从上往下堆化”通常发生在取出栈顶元素之后，我们拿出堆顶元素后，将最后一个元素放到堆顶，然后让该元素与其左右子节点进行对比，如果不满足子节点都小于等于父节点的关系，就把它与不符合要求的子节点交换。一直重复这个过程，直到父子节点之间满足关系。 由于每次我们都是对数组的最后一个元素进行操作，而且堆化进行的都是交换操作，所以不会出现数组”空洞”。 关于堆的代码实现，详细请看：https://loliwithpick.github.io/deny.github.io/2019/03/13/heap/ 堆排序（HeapSort）堆排序是基于堆实现的排序算法，它是一种原地排序算法，时间复杂度为 O(nlogn)，由于涉及到数据交换，所以它是不稳定的。 如何实现堆排序堆排序主要有两个操作：建堆和排序。 建堆建堆有两种方法： 借助在堆中插入一个元素的思想。假设数组中的数据存放在下标从 1 到 n 内，堆中只包含一个数据（下标为 1 的数据）。然后调用堆的插入方法，依次把剩下的数据插入到堆中。该方法是从下往上堆化的。 我们直接对数组进行堆化，而这种操作是从上往下堆化的。我们首先从最后一个非叶子节点开始，分别跟其左右子节点比较和堆化，依次往前。这么说法会很难理解，我们直接从代码方面下手。 123456789101112131415161718192021222324252627282930313233343536/** * 以现有数组构建小頂堆 * @param args */public void BuildMinHeap(int args[]) &#123; len = args.length; for (int i = len / 2; i &gt;= 0; i--) &#123; heapifly(args, i); &#125;&#125;/** * 从上往下堆化 * @param args * @param index */public void heapifly(int args[], int index) &#123; while(true) &#123; int left = index * 2; int right = index * 2 + 1; int max = index; if (left &lt; len &amp;&amp; args[left] &gt; args[index]) &#123; max = left; &#125; if (right &lt; len &amp;&amp; args[right] &gt; args[max]) &#123; max = right; &#125; if (max == index) break; swap(args, max, index); index = max; &#125;&#125; 在完全二叉树中，下标为 n/2 + 1 到 n 的节点是叶子节点。所以我们从下标为 n/2 开始，依次往前进行堆化的。所以我们只需从下标为 n/2 开始，依次往前进行堆化。 排序假设我们建的是大顶堆，那么建堆后，数组中的数据是按照大顶堆特性进行的。堆顶元素是最大的元素，我们将它与最后一个元素进行交换，那么最大的元素就放在下标为 n 的位置，然后我们将堆长度减一，重复进行前面的操作，最终就得到一个升序排序的数组。 123456789101112131415/** * 进行排序 * @param args */public void sort(int args[]) &#123; //判断数组是否有效或需要排序 if (args == null || args.length &lt; 1) return; BuildMinHeap(args); for (int i = args.length - 1; i &gt;= 0; i--) &#123; swap(args, 0, i); len--; heapifly(args, 0); &#125;&#125; 关于堆排序的代码实现，请观看：https://loliwithpick.github.io/deny.github.io/2019/03/13/heapSort/ 以上均为个人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/13/heapTheory/","date":"03-13","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/数据结构与算法/"}]},{"title":"解决SSM框架\"Could not get JDBC Connection\"问题","text":"Could not get JDBC Connection; nested exception is org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (Could not create connection to database server.) 这个问题主要在于 jdbc。上网搜了下，因为百度限制字数的问题，迟迟找不到。然后到处找找，排除了下，终于解决了问题。 下面，我列出觉得会引起该问题的一些情况给大家看看。 jdbc.properties 文件内容的规范1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/XXX（你的数据库名）jdbc.username=adminjdbc.password=123456 该文件一定要符合标准规范，有时候会因为 driver 变量没有 jdbc 的前缀而导致出错。 spring-mybatis.xml 文件内容的规范1234567891011121314151617&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;initialSize&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;maxActive&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;maxIdle&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;minIdle&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;maxWait&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; property 的 value 属性内容一定要跟 jdbc.properties 文件的变量名一致。 注意引用的 jdbc 版本是否与数据库版本相符 我的问题就出现在这，因为我使用的是 mysql 8，而我 pom.xml 文件引用的 jdbc 版本是 5.1.30，导致 jdbc 版本与数据库版本不符。 所以，如果 1、2 点无法解决你的问题，请留意下第三点。 以上皆为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/12/jdbcError/","date":"03-12","excerpt":"","tags":[{"name":"编程错误","slug":"编程错误","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/编程错误/"}]},{"title":"插入排序","text":"插入排序（Insertion Sort）的原理很简单和直观。它通过构建有序序列，对未排序数据，在已排序序列中从后往前扫描，找到相应位置并插入。从第一个元素开始，一般认为头元素是已经被排序的。 12345678910111213141516171819202122/** * 插入排序 * @param args * @return int[] */public int[] insertionSort(int[] args) &#123; //判断数组是否合法或需要排序 if (args == null || args.length &lt; 2) &#123; return args; &#125; for (int i = 1; i &lt; args.length; i++) &#123; int index = i, tmp = args[i]; while (index &gt; 0 &amp;&amp; args[index - 1] &gt; tmp) &#123; args[index] = args[index - 1]; index--; &#125; args[index] = tmp; &#125; return args;&#125; 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/11/insertionSort/","date":"03-11","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/数据结构与算法/"}]},{"title":"快速排序","text":"快速排序（Quick Sort）是一种常见的时间复杂度为 O(nlogn) 的排序算法（有些人会把空间复杂度写为 O(logn）)。 它通过一趟排序将数据分成两个独立的部分，其中，一部分的数据均比另一部分的数据要小，然后分别对这两部分数据继续进行排序，重复多次，以达到整个序列有序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 快速排序 * @param args * @param left * @param right * return int[] */public int[] quickSort(int[] args, int left, int right) &#123; if (left &lt; right) &#123; int pivot = partition(args, left, right); quickSort(args, left, pivot - 1); quickSort(args, pivot + 1, right); &#125; return args;&#125;/** * * @param args * @param left * @param right * @return int */private int partition(int[] args, int left, int right) &#123; int pivot = right, index = left; for (int i = left; i &lt; right; i++) &#123; if (args[i] &lt; args[pivot]) &#123; swap(args, i, index); index++; &#125; &#125; swap(args, index, pivot); return index;&#125;/** * 交换数据 * @param args * @param i * @param j */private void swap(int[] args, int i, int j) &#123; int tmp = args[i]; args[i] = args[j]; args[j] = tmp;&#125; 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/11/quickSort/","date":"03-11","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/数据结构与算法/"}]},{"title":"冒泡排序","text":"冒泡排序（Bubble Sort）每次比较两个元素，如果他们的顺序相反了，就把它们交换。在最极端的情况下，元素顺序刚好是倒序，冒泡排序需要比较 n 次（n 为元素个数），才能完成排序。 12345678910111213141516171819202122/** * 冒泡排序 * @param args * @return int[] */public int[] bubbleSort(int[] args) &#123; //判断数组是否合法或需要排序 if (args == null || args.length &lt; 2) return args; for (int i = 0; i &lt; args.length; i++) &#123; for (int j = 1; j &lt; args.length; j++) &#123; if (args[j] &gt; args[j - 1]) &#123; int tmp = args[j]; args[j] = args[j - 1]; args[j - 1] = tmp; &#125; &#125; &#125; return args;&#125; 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/11/bubbleSort/","date":"03-11","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/数据结构与算法/"}]},{"title":"人们对萝莉的偏见","text":"起因，这一两天在弄个人博客，就想要自己喜欢的主题类型，然后就找了个动漫萝莉风的主题，这主题，我是越看越喜欢。可就有些同学一看到就嗤之以鼻，就说“你这人，总喜欢这些，真是一个变态”。听得我就纳闷了，你们是不是对“萝莉”有什么偏见，“萝莉”可是这世界上最令人向往的存在。我来给你们分析下，为什么这么说。 首先，举个例子： 我喜欢萝莉 ∵ 萝莉 = 可爱的富婆 ∴ 我喜欢可爱的富婆 又∵ 富婆 = 有很多很多钱，钱 = 毛爷爷 ∴ 我喜欢可爱的毛爷爷 那么问题来了，谁不喜欢毛爷爷？ 所以，请你们不要误会那些喜欢萝莉的人了，他们基本上跟你们没有区别，只是比你们更喜欢毛爷爷而已。","path":"2019/03/11/人们对萝莉的偏见/","date":"03-11","excerpt":"","tags":[{"name":"日常吐槽","slug":"日常吐槽","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/日常吐槽/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/03/11/hello-world/","date":"03-11","excerpt":"","tags":[]},{"title":"Java基础：对Java的理解","text":"在了解 Java 之前，我们得知道面向对象和面向过程的优劣。 面向过程优势：类不需要实例化，所以性能要比面向对象高。对性能要求比较高的开发一般都采用面向过程语言，比如单片机、嵌入式开发、Linux/Unix 等。 劣势：没有面向对象易复用、易扩展、易维护。 面向对象优势：面向对象具有封装、继承和多态的特性。与面向过程相比，更容易复用、扩展和维护。不仅如此，还能设计出低耦合的系统，使系统更加灵活，更容易维护。 劣势：由于类的实例化开销较大，所以，性能比面向过程低。 关于封装、继承和多态封装封装是把一个对象的属性私有化，然后为每个属性创建 getter、setter 方法供外界访问。 继承继承是父子关系，以一个类作为父亲创建新类，新类又叫子类，子类拥有父类中非 private 的属性和方法，也可以拥有自己的属性和方法。通过继承，我们可以非常方便的复用代码。 多态多态是指在编程时，程序不知道引用变量会指向哪个类的实例对象，更不知道该变量的方法调用是哪个类实现的方法，只有在程序运行时才能确定。 Java 两大特性Java 本身是面向对象语言，具有面向对象的三大特点（封装、继承、多态），最显著的特性有两个方面，分别是“一次书写，到处运行。”和“垃圾收集“。 “一次书写，到处运行。”（Write once，run anywhere）Java 通过字节码和 JVM 跨平台的抽象屏蔽了系统和硬件的细节。 JVM 可理解的代码叫字节码（即后缀为 .class 的文件）。字节码不面向任何特定的处理器，只面向 JVM。而 JVM 针对不同系统有特定实现，目的是为了使用相同的字节码，在不同系统运行都会给出相同的结果。 JAVA 通过字节码的方式，在一定程度上解决了传统解释型语言执行效率的问题，同时也保留了解释型代码可移植的特点。因此，Java 具有“一次书写，到处运行”的特点。 “垃圾收集”（Garbage Collection）很多人都会拿 C++ 与 Java 相比，在 C++ 中，最令人头疼的就是内存管理问题，而 Java 的显著特点之一就是引入了垃圾回收机制，它会自动回收分配内存，使得 Java 程序员在大部分情况下都不需要操心内存的分配和回收。 Java 运行环境除了要知道 Java 的特性之外，我们还得知道 Java 的运行环境，JDK 和 JRE。 JRE（Java Runtime Environment）JRE 是 Java 的运行环境，包含了 JVM 和 Java 类库（核心类库、安全类库、第三方类库等），Java 命令和其他一些基础构建。但它不能用于创建新程序。 JDK（Java Development Kit）JDK 可看作是 JRE 的一个超集，包含 JRE 的一切，还提供了更多的工具（辅助工具：jlink、jar、jdeps 等，编译器：javac、sjavac 等，诊断工具：jmap、jstack、jconsole等）。能够创建和编译程序。 Java 是编译与解释并存的语言虽然 Java 是解释机制，但它是编译与解释并存的语言。 Java 代码从编译到运行的机制是：Java 代码经过 Javac 编译成 .class 文件，然后 JVM 类加载器加载 .class 文件，最后通过解释器逐行解释运行。照这么说法，Java 应该是解释执行才对，何来的编译呢？其实，这种方法的执行速度相对较慢，并且有些代码块经常被调用，在时间消耗上占了很大一部分。所以，存在 JIT（Just-In-Time）编译器，把经常运行的代码作为“热点代码”编译成本地平台相关的机器码，并进行各种层次的优化。所以，Java 是编译与解释并存的语言。 JDK 9 引入了新的编译模式 AOT，它预先把字节码编译成机器码。 如果需要了解 JIT 和 AOT，详细请观看 JIT（动态编译）和AOT（静态编译）编译技术比较 Java 与 C++ 的区别据闻，很多时候都会拿 Java 和 C++ 作比较，本人看来，每个语言都有它的特点，得看情况使用。 它们都是面向对象语言，都支持封装、继承和多态。 Java 没有指针，程序内存更安全。 C++ 支持多重继承，而 Java 只支持单继承，但可以有多个接口。 Java 能自动回收和分配内存，一般情况下，不需要手动释放内存。 C++ 支持本地的无符号数学运算，而 Java 不支持。 以上均为本人学习时的笔录总结，若有错误之处，请多多指教。","path":"2019/03/10/对Java的理解/","date":"03-10","excerpt":"","tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/LoliWithPick/deny.github.io/tags/编程语言/"}],"preview":"/deny.github.io/imgs/preview/preview5.jpg"}]}